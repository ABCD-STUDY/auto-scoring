## Runner

```
Run the recipe FirstTest:
  ./runner.js run ../viewer/recipes/FirstTest.json

Run the recipe FirstTest and create a history file with updates of each node for debugging:
  ./runner.js run -h history.txt ../viewer/recipes/FirstTest.json

Run the recipe FirstTest for 1,000 iterations and keep a history file. If the state file
exists already add 1,000 additional computational steps:
  ./runner.js run -d /tmp/state.json -s 1000 -h history.txt ../viewer/recipes/FirstTest.json
```

The runner will execute the graph in stages. Each stage or epoch processes one set of input data, in our project a participant ID, a visit or event name and a set of raw scores (numbers or strings). During the epoch the input values to the graph will be fixed and all nodes in the graph will be called in a random order until no change in the graph is detected. This finishes the current epoch and the next epoch is started with a new set of input data. The runner finishes of there is no more data to process.

### Implementing a new node

The runner signals different processing requests to the nodes by calling named functions in each node's code. The different functions names create the node API supported by this runner. Here an example for the simplest of all nodes that implements logical not:
```
var Not = function () { // constructor
    this._condition = function(a) { return !(a); };
};

Not.prototype.work = function (inputs, outputs, state) {
    outputs['out'] = this._condition;
};

module.exports = Not;   // is imported by runner.js
```
It is essential to the function of this node to create the return value (a function) in the constructor. If the node would create the returned function in its 'work' call every call a new function object would be created. The runner would assume that the node did some work (changed the return value) even it it did not. As a result the runner would not be able to detect the end of an epoch and we run into a endless loop. Make sure to keep the outputs of your node stable. They should not change in different iterations of the graph. In this case Not was born being done.

The node module needs to be imported in runner.js and must be part of the runner's work function switch statement. Together with this node implementation in the runner directory the viewer also needs to define the corresponding user interface in its items.json file section:
```JSON
{
  "name": "not",
  "id": "not",
  "group": "Logic",
  "description": "Logic Expression - Not",
  "inputs": [
      { "name": "in", "type": "all" }
  ],
  "outputs": [
      { "name": "out", "type": "all" }
  ]
},
```

### Node API

Nodes can implement the following functions to react to signals from the runner.

#### Constructor [Named function]

Called once if the graph is created. Use this place to perform initialization of your modules. The REDCap_get module for example uses this location to start all the data pull operations. Here the much simplier example of the not-node that just creates a comparison functionn as an internal variable:
```javascript
var Not = function () {
    this._condition = function(a) { return !(a); };
};
```

#### Destructor [cleanUp() added to prototype]

Called if the runner decides that no more work can be done (end of all epochs). Use this function if your node needs to do some clean-up after itself. The REDCap_put node for example uses this call to send the last remaining scores back to the database.
```javascript
RedcapPut.prototype.cleanUp = function () {
    sendToREDCap( { scores: this._results } );
    console.log("Results after sending (" + this._results.length + "): \n" +
		JSON.stringify(this._results, null, '  '));
}
```

#### Work [work() added to prototype]

Called each time a computation is requested. This function will get three arguments: `inputs`, `outputs`, and `state`. Inputs is a dictionary with keys that reference inputs from the items.json definition and values that contain the current values generated by the connections to this node. Outputs is an empty dictionary that should be filled with named output values according to the items.json definition of this node. Here an example from the function calculating the mean over the connected inputs. The node also computes the number of missing and the total number of values as additional outputs.

```JSON
// from items.json
{   "name": "mean",
    "id": "mean",
    "group": "Arithmetic",
    "description": "Mean of all connected values",
    "inputs": [
        { "name": "in1", "type": "all" },
        { "name": "in2", "type": "all" },
	    ...
    ],
    "outputs": [
        { "name": "out", "type": "all" },
        { "name": "num_missing", "type": "all" },
        { "name": "num_total", "type": "all" }
    ]
},
```

```javascript
// from nodes/mean.js
Mean.prototype.work = function (inputs, outputs, state) {
    var sum = 0.0;
    var num_missing = 0;
    var num_present = 0;
    var obj = Object.keys(inputs);
    for (var i = 0; i < obj.length; i++) {
        if (inputs[obj[i]] === "" || inputs[obj[i]] === undefined) {
            num_missing = num_missing + 1;
            continue;
        }
        num_present = num_present + 1;
        sum = sum + parseFloat(inputs[obj[i]]);
    }
    if (num_present > 0) {
        outputs['out'] = sum / num_present;
    }
    outputs['num_missing'] = num_missing;
    outputs['num_total']   = obj.length;
};
```
The work-function above will not produce a key/value for the mean if no values are present. Nodes in general should not assume that specific inputs are present (key might not exist in inputs dictionary). Nodes should also test the existing keys values for 'undefined'.

The state array is structured as a more complex object and contains state variables exposed on the user interface. The IF-Else node for example used the state variables to store default values for its inputs. If a connection exists any existing state variable will be ignored (overwritten) by the data coming through the connection from the connecting node. The REDCap_get and REDCap_put nodes use state variables to store the names of the variables that should be pulled and pushed from/to REDCap.  

#### doneDone [ boolean = doneDone() added to prototype]

Only needs to be implemented for input nodes to the recipe. This function is called frequently by the runner. The node can indicate in its return argument if there is more data to be processed. The REDCap_get node will return false if it is still waiting for data to arrive from REDCap or if there is still participant data in its internal buffer for processing.
```javascript
RedcapGet.prototype.doneDone = function() {
    if (this._numCalls > 0 || this._participants.length > 0) {
            return false; // still work to do in the next epoch
    }
    return true; // nothing more to do		    
}
```

#### startEpoch [ startEpoch() added to prototype]

This function is called at the very beginning of an epoch. The two example nodes redcap_get and redcap_put do not implement this function. Instead they react to the end of an epoch (endEpoch) only.

#### endEpoch [ added to prototype ]

This function is called at the end of every epoch. REDCap_get is using this function to advance to the next participant for processing.

```javascript
RedcapGet.prototype.endEpoch = function () {
    this._participants.shift(); // get the next subject      
}
```

#### readyForEpoch [ boolean = readyForEpch() added to prototype ]

This function is implemented by the REDCap_get input node and returns true as soon as the first dataset is ready for processing.

```javascript
RedcapGet.prototype.readyForEpoch = function () {
    return !this._waitingForData;
}
```
