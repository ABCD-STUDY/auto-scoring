## Runner

```
  ./runner.js run -i ../viewer/recipes/FirstTest.json
```

The runner will execute the graph in stages. Each stage or epoch processes one set of input data, in this case a participant ID, a visit or event name and a set of raw scores (numbers or strings). During the epoch the input values to the graph will be fixed and all nodes in the graph will be called in a random order until no change in the graph is detected. This finishes the current epoch and the next epoch is started with a new set of input data. The runner finishes of there is no more data to process.

### Implementing a new node

The runner signals different processing requests to the nodes by calling named functions in each node's code. The different functions names create the node API supported by this runner. Here an example for the simplest of all nodes that implements logical not:
```
var Not = function () { // constructor
    this._condition = function(a) { return !(a); };
};

Not.prototype.work = function (inputs, outputs, state) {
    outputs['out'] = this._condition;
};

module.exports = Not;   // is imported by runner.js
```
Its essential to create the return function in the constructor of Not. If we would create the function in work it would be a different function every time the work() function is called. In that case the runner would assume that the node did some work even it it did not. Make sure to keep the outputs stable - the same - in different iterations of the graph if you are done with the work. In this case not was born being ready.

The node module needs to be imported in runner.js and must be part of the runner's work function switch statement. Together with this node implementation in the runner directory the viewer also needs to define the corresponding user interface in its items.json file section:
```JSON
{
  "name": "not",
  "id": "not",
  "group": "Logic",
  "description": "Logic Expression - Not",
  "inputs": [
      { "name": "in", "type": "all" }
  ],
  "outputs": [
      { "name": "out", "type": "all" }
  ]
},
```

### Node API

Nodes can implement the following functions to react to signals from the runner.

#### Constructor [Named function]

Called once if the graph is created. Use this place to perform initialization of your modules. The REDCap_get module for example uses this location to start all the data pull operations. Here the much simplier example of the not-node that just creates a comparison functionn as an internal variable:
```javascript
var Not = function () {
    this._condition = function(a) { return !(a); };
};
```

#### Destructor [cleanUp() added to prototype]

Called if the runner decides that no more work can be done. Use this function if your node needs to clean-up after itself. The REDCap_put node for example uses this call to send the last remaining scores back to the database.
```javascript
RedcapPut.prototype.cleanUp = function () {
    sendToREDCap( { scores: this._results } );
    console.log("Results after sending (" +
    	        this._results.length +
		"): \n" +
		JSON.stringify(this._results, null, '  '));
}
```

#### Work [work() added to prototype]

Called each time a computation is required. This function will get three arguments: `inputs, outputs, state`. Inputs is as a dictionary with keys that reference inputs from the items.json definition of this node and values that contain the current values generated by the connections to this node. Outputs is an empty dictionary that should be filled with named output values according to the items.json definition of this node. Here an example from the function calculating the mean over the connected inputs and the number of missing and the total number of values:
```javascript
Mean.prototype.work = function (inputs, outputs, state) {
    var sum = 0.0;
    var num_missing = 0;
    var num_present = 0;
    var obj = Object.keys(inputs);
    for (var i = 0; i < obj.length; i++) {
        if (inputs[obj[i]] === "" || inputs[obj[i]] === undefined) {
            num_missing = num_missing + 1;
            continue;
        }
        num_present = num_present + 1;
        sum = sum + parseFloat(inputs[obj[i]]);
    }
    if (num_present > 0) {
        outputs['out'] = sum / num_present;
    }
    outputs['num_missing'] = num_missing;
    outputs['num_total']   = obj.length;
};
```
The work-function above will not produce a key/value for the mean if no values are present. Nodes in general should not assume that specific inputs are present (keys can not exist in inputs). Nodes also need to test the existing keys values for 'undefined'.

The state array is structured as a more complex object and contains any state variables exposed on the user interface. The IF-Else node for example used the state variables to store default values for its inputs. If a connection exists any existing state variable will be ignored (overwritten) by the data coming through the connection from the connecting node. The REDCap_get and REDCap_put nodes use state variables to store the names of the variables that should be pulled and pushed from/to REDCap.  

#### Done [ boolean = done() added to prototype]

Only needs to be implemented for input or output nodes to the recipe. This function is called frequently by the runner to ask the node to indicate if there is more things it can do in this iteration. The REDCap_get node will return false if it is still waiting for data to arrive from REDCap.
```javascript
RedcapGet.prototype.done = function() {
    // indicate that there was a change if we are just waiting for data coming in
    return !this._waitingForData;
}
```

#### Epoch [ boolean = epoch(int) added to prototype]

Only if you are an input or output node to the recipe you need to implement this function. It is called by the runner if no more changes in the recipe can be detected. The runner checks for changes by keeping a record of the inputs, outputs and state fields of each work()-call.

The epoch function gets as an argument an integer that is the current epoch number. If the node stores this number in a node internal variable it can check if a new epoch was started by the calling runner.

The epoch function of the node should return either `false` - if there is more data it could produce or 'true' if there is no more data it can generate. Here an example from the REDCap_get node:
```javascript
RedcapGet.prototype.epoch = function (epoch) {
    if (epoch !== this._currentEpoch) {
        this._nextEpoch = true;  // provide the next participant's data
        this._currentEpoch = epoch;
    }
    if (this._numCalls > 0 || this._participants.length > 0) {
        return false; // still work to do in the next epoch
    }

    return true; // we are doneDone, no more participants
}
```
The implementation compares the provided epoch number with one stored from the previous call and stores the information in the indicator variable _nextEpoch. If there is more internal data, for example if there are still calls running to pull data (_numCalls) or if the internal data buffer _participants is not empty it will return 'false' to indicate that there is more work to be done in the next epoch.


